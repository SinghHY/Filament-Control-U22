CCS PCD C Compiler, Version 5.074, 35380               22-Nov-17 16:25

               Filename:   C:\GitRepo\Filament-Control-U22\Filament Control.X\build\default\production\Main.lst

               ROM used:   1012 bytes (1%)
                           Largest free fragment is 65536
               RAM used:   138 (0%) at main() level
                           138 (0%) worst case
               Stack used: 44 locations (2 in main + 42 for interrupts)
               Stack size: 128

*
00000:  GOTO    370
*
00056:  DATA    2C,02,00
.................... #include <33FJ256GP710A.h> 
.................... //////////// Standard Header file for the DSPIC33FJ256GP710A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device DSPIC33FJ256GP710A 
....................  
.................... #list 
....................  
.................... #fuses XT,NOWDT,NOPROTECT 
.................... #use delay(crystal = 8Mhz, clock = 100Mhz) 
*
00354:  CP0     W0
00356:  BTSC.B  42.1
00358:  BRA     36E
0035A:  REPEAT  #34B
0035C:  NOP     
0035E:  REPEAT  #3FFE
00360:  NOP     
00362:  REPEAT  #3FFE
00364:  NOP     
00366:  REPEAT  #3FFE
00368:  NOP     
0036A:  DEC     W0,W0
0036C:  BRA     NZ,35A
0036E:  RETURN  
.................... #use spi(SLAVE, SPI2, BITS = 8, MODE = 1, ENABLE = PIN_G9, stream = SPI_2) 
*
00200:  MOV     W5,[W15++]
00202:  MOV     #8,W3
00204:  CP      W2,#8
00206:  BRA     Z,216
00208:  MOV     #9,W3
0020A:  CP      W2,#10
0020C:  BRA     Z,216
0020E:  MOV     #A,W3
00210:  CP      W2,#18
00212:  BRA     Z,216
00214:  MOV     #B,W3
00216:  BTSS.B  260.0
00218:  BRA     216
0021A:  MOV.B   268,W0L
0021C:  MOV.B   W0L,[W3--]
0021E:  BCLR.B  260.6
00220:  SUB.B   #8,W2L
00222:  BRA     GTU,216
00224:  MOV     W4,W0
00226:  MOV     W5,W1
00228:  MOV     [--W15],W5
0022A:  RETURN  
....................  
.................... #define LED PIN_A3 
.................... #define LED2 PIN_A0 
....................  
.................... int8 SPI_Flag = 0, Byte_Count = 0, Rx, Tx, Cmand, ProbeID = 2, count = 0; 
.................... int8 Version = 7; 
....................  
....................  
.................... #INT_SPI2 
....................  
.................... void spi2_slave_isr(void) 
0022C:  PUSH    42
0022E:  PUSH    36
00230:  PUSH    32
00232:  MOV     W0,[W15++]
00234:  MOV     #2,W0
00236:  REPEAT  #C
00238:  MOV     [W0++],[W15++]
.................... { 
....................   Rx = spi_xfer_in(SPI_2, 8); 
0023A:  MOV     #8,W2
0023C:  CALL    200
00240:  MOV.B   W0L,803
....................   Byte_Count++;  
00242:  INC.B   0802
....................   switch(Byte_Count) 
00244:  MOV.B   802,W0L
00246:  SE      W0,W0
00248:  XOR     #1,W0
0024A:  BRA     Z,25A
0024C:  XOR     #3,W0
0024E:  BRA     Z,286
00250:  XOR     #1,W0
00252:  BRA     Z,2D2
00254:  XOR     #7,W0
00256:  BRA     Z,31A
00258:  BRA     33C
....................         { 
....................             case 1: 
....................                 spi_prewrite(Version); 
0025A:  MOV.B   808,W0L
0025C:  MOV.B   W0L,800
0025E:  MOV.B   800,W0L
00260:  MOV.B   W0L,268
00262:  MOV.B   #1,W0L
00264:  MOV.B   W0L,800
....................                 if(Cmand == 1) 
00266:  MOV.B   805,W0L
00268:  SE      W0,W0
0026A:  CP      W0,#1
0026C:  BRA     NZ,276
....................                    count = Rx; 
0026E:  MOV.B   803,W0L
00270:  MOV.B   W0L,807
00272:  GOTO    282
....................                 else if(Cmand == 2) 
00276:  MOV.B   805,W0L
00278:  SE      W0,W0
0027A:  CP      W0,#2
0027C:  BRA     NZ,282
....................                    count = Rx; 
0027E:  MOV.B   803,W0L
00280:  MOV.B   W0L,807
....................                 break; 
00282:  GOTO    342
....................  
....................             case 2:  
....................                 Cmand = Rx; 
00286:  MOV.B   803,W0L
00288:  MOV.B   W0L,805
....................  
....................                 if(Cmand == 1) 
0028A:  MOV.B   805,W0L
0028C:  SE      W0,W0
0028E:  CP      W0,#1
00290:  BRA     NZ,2A2
....................                    spi_prewrite(25); 
00292:  MOV.B   #19,W0L
00294:  MOV.B   W0L,800
00296:  MOV.B   800,W0L
00298:  MOV.B   W0L,268
0029A:  MOV.B   #1,W0L
0029C:  MOV.B   W0L,800
0029E:  GOTO    2CE
....................                 else if(Cmand == 2) 
002A2:  MOV.B   805,W0L
002A4:  SE      W0,W0
002A6:  CP      W0,#2
002A8:  BRA     NZ,2BA
....................                         spi_prewrite(35); 
002AA:  MOV.B   #23,W0L
002AC:  MOV.B   W0L,800
002AE:  MOV.B   800,W0L
002B0:  MOV.B   W0L,268
002B2:  MOV.B   #1,W0L
002B4:  MOV.B   W0L,800
002B6:  GOTO    2CE
....................                 else if(Cmand == 3) 
002BA:  MOV.B   805,W0L
002BC:  SE      W0,W0
002BE:  CP      W0,#3
002C0:  BRA     NZ,2CE
....................                         spi_prewrite(ProbeID); 
002C2:  MOV.B   806,W0L
002C4:  MOV.B   W0L,800
002C6:  MOV.B   800,W0L
002C8:  MOV.B   W0L,268
002CA:  MOV.B   #1,W0L
002CC:  MOV.B   W0L,800
....................                 break; 
002CE:  GOTO    342
....................              
....................             case 3:  
....................                 if(Cmand == 1) 
002D2:  MOV.B   805,W0L
002D4:  SE      W0,W0
002D6:  CP      W0,#1
002D8:  BRA     NZ,2EA
....................                    spi_prewrite(45); 
002DA:  MOV.B   #2D,W0L
002DC:  MOV.B   W0L,800
002DE:  MOV.B   800,W0L
002E0:  MOV.B   W0L,268
002E2:  MOV.B   #1,W0L
002E4:  MOV.B   W0L,800
002E6:  GOTO    316
....................                 else if(Cmand == 2) 
002EA:  MOV.B   805,W0L
002EC:  SE      W0,W0
002EE:  CP      W0,#2
002F0:  BRA     NZ,302
....................                    spi_prewrite(SPI_Flag); 
002F2:  MOV.B   801,W0L
002F4:  MOV.B   W0L,800
002F6:  MOV.B   800,W0L
002F8:  MOV.B   W0L,268
002FA:  MOV.B   #1,W0L
002FC:  MOV.B   W0L,800
002FE:  GOTO    316
....................                 else if(Cmand == 3) 
00302:  MOV.B   805,W0L
00304:  SE      W0,W0
00306:  CP      W0,#3
00308:  BRA     NZ,316
....................                    spi_prewrite(SPI_Flag); 
0030A:  MOV.B   801,W0L
0030C:  MOV.B   W0L,800
0030E:  MOV.B   800,W0L
00310:  MOV.B   W0L,268
00312:  MOV.B   #1,W0L
00314:  MOV.B   W0L,800
....................                 break;       
00316:  GOTO    342
....................                  
....................             case 4:  
....................                 Byte_Count = 0; 
0031A:  CLR.B   802
....................                 if(Cmand == 1) 
0031C:  MOV.B   805,W0L
0031E:  SE      W0,W0
00320:  CP      W0,#1
00322:  BRA     NZ,32C
....................                    count = Rx; 
00324:  MOV.B   803,W0L
00326:  MOV.B   W0L,807
00328:  GOTO    338
....................                 else if(Cmand == 2) 
0032C:  MOV.B   805,W0L
0032E:  SE      W0,W0
00330:  CP      W0,#2
00332:  BRA     NZ,338
....................                     count = Rx; 
00334:  MOV.B   803,W0L
00336:  MOV.B   W0L,807
....................                  
....................  
....................                 break;                 
00338:  GOTO    342
....................             default: 
....................                 Byte_Count = 0; 
0033C:  CLR.B   802
....................                 break;         
0033E:  GOTO    342
....................         } 
....................  
00342:  BCLR.B  88.1
00344:  MOV     #1A,W0
00346:  REPEAT  #C
00348:  MOV     [--W15],[W0--]
0034A:  MOV     [--W15],W0
0034C:  POP     32
0034E:  POP     36
00350:  POP     42
00352:  RETFIE  
.................... } 
....................  
....................  
....................  
....................  
.................... void main() 
*
00370:  MOV     #7780,W15
00372:  MOV     #77FF,W0
00374:  MOV     W0,20
00376:  NOP     
00378:  BSET.B  81.7
0037A:  MOV     #30,W4
0037C:  MOV     W4,746
0037E:  CLR     744
00380:  DISI    #E
00382:  MOV     #103,W0
00384:  MOV     #743,W1
00386:  MOV     #78,W2
00388:  MOV     #9A,W3
0038A:  MOV.B   W2L,[W1]
0038C:  MOV.B   W3L,[W1]
0038E:  MOV.B   W0L,743
00390:  LSR     W0,#8,W0
00392:  MOV     #742,W1
00394:  MOV     #46,W2
00396:  MOV     #57,W3
00398:  MOV.B   W2L,[W1]
0039A:  MOV.B   W3L,[W1]
0039C:  MOV.B   W0L,[W1]
0039E:  CLR.B   800
003A0:  BCLR.B  261.7
003A2:  BCLR.B  2E5.0
003A4:  BSET.B  2E4.7
003A6:  BSET.B  2E5.1
003A8:  BSET.B  2E4.6
003AA:  BCLR.B  260.6
003AC:  BCLR.B  263.1
003AE:  CLR     268
003B0:  MOV     #1097,W4
003B2:  MOV     W4,262
003B4:  BSET.B  261.7
003B6:  BCLR.B  2E5.1
003B8:  BSET.B  2E9.1
003BA:  CLR.B   801
003BC:  CLR.B   802
003BE:  MOV.B   #2,W0L
003C0:  MOV.B   W0L,806
003C2:  CLR.B   807
003C4:  MOV.B   #7,W0L
003C6:  MOV.B   W0L,808
003C8:  SETM    32C
003CA:  SETM    32A
003CC:  SETM    36C
003CE:  SETM    36A
.................... {     
....................    output_float(PIN_G9); // SS as an input 
003D0:  BSET.B  2E5.1
....................     
....................    enable_interrupts(INT_SPI2); 
003D2:  BSET.B  98.1
....................    enable_interrupts(INTR_GLOBAL); 
003D4:  BCLR.B  81.7
003D6:  CLR     42
003D8:  BSET.B  81.7
....................     
....................     
....................    while(1) 
....................     { 
....................        output_high(LED); 
003DA:  BCLR.B  2C0.3
003DC:  BSET.B  2C4.3
....................        delay_ms(1000); 
003DE:  MOV     #3E8,W0
003E0:  CALL    354
....................        output_low(LED); 
003E4:  BCLR.B  2C0.3
003E6:  BCLR.B  2C4.3
....................        delay_ms(1000); 
003E8:  MOV     #3E8,W0
003EA:  CALL    354
003EE:  GOTO    3DA
....................  
....................     } 
.................... }    
*
003F2:  PWRSAV  #0

Configuration Fuses:
   Word  1L: 00CF   NOWRTB NOBSS NORBS
          H: 0000  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: 0000  
   Word  3L: 0007   NOWRT NOPROTECT
          H: 0000  
   Word  4L: 0080   FRC IESO
          H: 0000  
   Word  5L: 0041   XT OSCIO CKSNOFSM
          H: 0000  
   Word  6L: 005F   WPOSTS16 WPRES128 WINDIS NOWDT
          H: 0000  
   Word  7L: 00E7   PUT128
          H: 0000  
   Word  8L: 00C3   ICSP1 NOJTAG NODEBUG
          H: 0000  
